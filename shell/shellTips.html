<!DOCTYPE HTML PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN">
<html>
<head>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<title>shellTips</title>
<link rel="stylesheet" type="text/css" href="../template/style/main.css" />
<link type="text/css" rel="stylesheet" href="../template/style/shCore.css"/>
<link type="text/css" rel="stylesheet" href="../template/style/shCoreRDark.css"/>
<script type="text/javascript" src="../template/js/jquery.js"></script>
<!--For code highlighting-->
<script type="text/javascript" src="../template/js/shCore.js"></script>
<script type="text/javascript" src="../template/js/shBrushPlain.js"></script>
<script type="text/javascript" src="../template/js/shBrushVim.js"></script>
<script type="text/javascript" src="../template/js/shBrushBash.js"></script>
<script type="text/javascript" src="../template/js/shBrushCss.js"></script>
<script type="text/javascript" src="../template/js/shBrushJava.js"></script>
<script type="text/javascript" src="../template/js/shBrushJScript.js"></script>
<script type="text/javascript" src="../template/js/shBrushPython.js"></script>
<script type="text/javascript" src="../template/js/shBrushSql.js"></script>
<script type="text/javascript" src="../template/js/shBrushXml.js"></script>

<script type="text/javascript">
$(document).ready(function() {
		SyntaxHighlighter.all();
		if (window.innerWidth >= 460) {
		var toggler = $('<div class="toggler" title="Toggle Table Of Content">Table Of Content</div>');
		toc = $('.toc');
		toc.wrap('<div class="tocWrap">');

		$('.tocWrap').prepend(toggler)
		.delay(500)
		.fadeTo(500, '0.7')
		.hover(function() {
			$(this).stop().fadeTo(300, '0.9');
			}, function() {
			$(this).stop().fadeTo(300, '0.7');
			});

		$('html').keypress(function(e) {
			if (e.shiftKey && (e.charCode || e.keyCode) == '90') {
			e.preventDefault();
			$('div.tocWrap').toggle(200);
			}
			});

		toggler.click(function() {
				$('div.toc').slideToggle(300);
				});
		}

		$("a,h1,h2,h3,h4,h5,h6").filter(function(index){
			return $(this).text()=='!Important!';
				}).addClass("importantMarker");

		

});



</script>
</head>
<body >
<header id="header">
<div id="logo" style="font-size: 22pt;text-align:center;"><a href="#">Kent's Wiki</a></div>
</header>
<div id="wrap">
<div id="content">

<div class="toc">
<ul>
<li><a href="#toc_1">variable expansion</a>
<li><a href="#toc_2">output overwrites same screen area</a>
</ul>
</div>

<h1 id="toc_1">variable expansion</h1>
<pre  class="brush: bash">

${parameter:-word}
If parameter is unset or null, the expansion of word is substituted. Otherwise, the value of parameter is substituted.

${parameter:=word}
If parameter is unset or null, the expansion of word is assigned to parameter. The value of parameter is then substituted. Positional parameters and special parameters may not be assigned to in this way.

${parameter:?word}
If parameter is null or unset, the expansion of word (or a message to that effect if word is not present) is written to the standard error and the shell, if it is not interactive, exits. Otherwise, the value of parameter is substituted.

${parameter:+word}
If parameter is null or unset, nothing is substituted, otherwise the expansion of word is substituted.

${parameter:offset}
${parameter:offset:length}
Expands to up to length characters of parameter starting at the character specified by offset. If length is omitted, expands to the substring of parameter starting at the character specified by offset. length and offset are arithmetic expressions (see Shell Arithmetic). This is referred to as Substring Expansion.

If offset evaluates to a number less than zero, the value is used as an offset from the end of the value of parameter. If length evaluates to a number less than zero, and parameter is not ‘@’ and not an indexed or associative array, it is interpreted as an offset from the end of the value of parameter rather than a number of characters, and the expansion is the characters between the two offsets. If parameter is ‘@’, the result is length positional parameters beginning at offset. If parameter is an indexed array name subscripted by ‘@’ or ‘*’, the result is the length members of the array beginning with ${parameter[offset]}. A negative offset is taken relative to one greater than the maximum index of the specified array. Substring expansion applied to an associative array produces undefined results.

Note that a negative offset must be separated from the colon by at least one space to avoid being confused with the ‘:-’ expansion. Substring indexing is zero-based unless the positional parameters are used, in which case the indexing starts at 1 by default. If offset is 0, and the positional parameters are used, $@ is prefixed to the list.

${!prefix*}
${!prefix@}
Expands to the names of variables whose names begin with prefix, separated by the first character of the IFS special variable. When ‘@’ is used and the expansion appears within double quotes, each variable name expands to a separate word.

${!name[@]}
${!name[*]}
If name is an array variable, expands to the list of array indices (keys) assigned in name. If name is not an array, expands to 0 if name is set and null otherwise. When ‘@’ is used and the expansion appears within double quotes, each key expands to a separate word.

${#parameter}
The length in characters of the expanded value of parameter is substituted. If parameter is ‘*’ or ‘@’, the value substituted is the number of positional parameters. If parameter is an array name subscripted by ‘*’ or ‘@’, the value substituted is the number of elements in the array.

${parameter#word}
${parameter##word}
The word is expanded to produce a pattern just as in filename expansion (see Filename Expansion). If the pattern matches the beginning of the expanded value of parameter, then the result of the expansion is the expanded value of parameter with the shortest matching pattern (the ‘#’ case) or the longest matching pattern (the ‘##’ case) deleted. If parameter is ‘@’ or ‘*’, the pattern removal operation is applied to each positional parameter in turn, and the expansion is the resultant list. If parameter is an array variable subscripted with ‘@’ or ‘*’, the pattern removal operation is applied to each member of the array in turn, and the expansion is the resultant list.

${parameter%word}
${parameter%%word}
The word is expanded to produce a pattern just as in filename expansion. If the pattern matches a trailing portion of the expanded value of parameter, then the result of the expansion is the value of parameter with the shortest matching pattern (the ‘%’ case) or the longest matching pattern (the ‘%%’ case) deleted. If parameter is ‘@’ or ‘*’, the pattern removal operation is applied to each positional parameter in turn, and the expansion is the resultant list. If parameter is an array variable subscripted with ‘@’ or ‘*’, the pattern removal operation is applied to each member of the array in turn, and the expansion is the resultant list.

${parameter/pattern/string}
The pattern is expanded to produce a pattern just as in filename expansion. Parameter is expanded and the longest match of pattern against its value is replaced with string. If pattern begins with ‘/’, all matches of pattern are replaced with string. Normally only the first match is replaced. If pattern begins with ‘#’, it must match at the beginning of the expanded value of parameter. If pattern begins with ‘%’, it must match at the end of the expanded value of parameter. If string is null, matches of pattern are deleted and the / following pattern may be omitted. If parameter is ‘@’ or ‘*’, the substitution operation is applied to each positional parameter in turn, and the expansion is the resultant list. If parameter is an array variable subscripted with ‘@’ or ‘*’, the substitution operation is applied to each member of the array in turn, and the expansion is the resultant list.

${parameter^pattern}
${parameter^^pattern}
${parameter,pattern}
${parameter,,pattern}
This expansion modifies the case of alphabetic characters in parameter. The pattern is expanded to produce a pattern just as in filename expansion. The ‘^’ operator converts lowercase letters matching pattern to uppercase; the ‘,’ operator converts matching uppercase letters to lowercase. The ‘^^’ and ‘,,’ expansions convert each matched character in the expanded value; the ‘^’ and ‘,’ expansions match and convert only the first character in the expanded value. If pattern is omitted, it is treated like a ‘?’, which matches every character. If parameter is ‘@’ or ‘*’, the case modification operation is applied to each positional parameter in turn, and the expansion is the resultant list. If parameter is an array variable subscripted with ‘@’ or ‘*’, the case modification operation is applied to each member of the array in turn, and the expansion is the resultant list.

</pre>
<h1 id="toc_2">output overwrites same screen area</h1>

<pre class="brush: bash">

tput cuu1 #move cursor oneline up
tput el   #clear till the end of line

#tput reset/set terminal,shell
#man terminfo would list all capabilities
</pre>

<p>
Example (<a href="http://stackoverflow.com/questions/18640002/is-it-possible-to-have-bash-script-output-multiple-lines-over-the-same-lines-wit)">http://stackoverflow.com/questions/18640002/is-it-possible-to-have-bash-script-output-multiple-lines-over-the-same-lines-wit)</a>
</p>
<pre class="brush: bash">
while true; do    
    date
    sensors | grep "temp1"
    sensors | grep "Core"
    acpi

    sleep 1

    for i in {1..4}; do # clear four lines above
        tput cuu1 # up by one line
        tput el # clear that line
    done
done
</pre>



<p>
<a href="../index.html">&lt;&lt;Back</a>
</p>

</div>
</div>
<div id="footer">
<a href="http://www.vim.org" target="_blank"><img border="0" src="../template/images/vimLogo.png" alt="Created with Vim" height="36" width="90"></a>
</div>
</body>
</html>
